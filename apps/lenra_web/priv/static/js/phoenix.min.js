"use strict";
var exports = {}
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Presence = exports.Ajax = exports.LongPoll = exports.Socket = exports.Serializer = exports.Channel = void 0;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return !!right[Symbol.hasInstance](left); } else { return left instanceof right; } }

function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Phoenix Channels JavaScript client
 *
 * ## Socket Connection
 *
 * A single connection is established to the server and
 * channels are multiplexed over the connection.
 * Connect to the server using the `Socket` class:
 *
 * ```javascript
 * let socket = new Socket("/socket", {params: {userToken: "123"}})
 * socket.connect()
 * ```
 *
 * The `Socket` constructor takes the mount point of the socket,
 * the authentication params, as well as options that can be found in
 * the Socket docs, such as configuring the `LongPoll` transport, and
 * heartbeat.
 *
 * ## Channels
 *
 * Channels are isolated, concurrent processes on the server that
 * subscribe to topics and broker events between the client and server.
 * To join a channel, you must provide the topic, and channel params for
 * authorization. Here's an example chat room example where `"new_msg"`
 * events are listened for, messages are pushed to the server, and
 * the channel is joined with ok/error/timeout matches:
 *
 * ```javascript
 * let channel = socket.channel("room:123", {token: roomToken})
 * channel.on("new_msg", msg => console.log("Got message", msg) )
 * $input.onEnter( e => {
 *   channel.push("new_msg", {body: e.target.val}, 10000)
 *     .receive("ok", (msg) => console.log("created message", msg) )
 *     .receive("error", (reasons) => console.log("create failed", reasons) )
 *     .receive("timeout", () => console.log("Networking issue...") )
 * })
 *
 * channel.join()
 *   .receive("ok", ({messages}) => console.log("catching up", messages) )
 *   .receive("error", ({reason}) => console.log("failed join", reason) )
 *   .receive("timeout", () => console.log("Networking issue. Still waiting..."))
 *```
 *
 * ## Joining
 *
 * Creating a channel with `socket.channel(topic, params)`, binds the params to
 * `channel.params`, which are sent up on `channel.join()`.
 * Subsequent rejoins will send up the modified params for
 * updating authorization params, or passing up last_message_id information.
 * Successful joins receive an "ok" status, while unsuccessful joins
 * receive "error".
 *
 * ## Duplicate Join Subscriptions
 *
 * While the client may join any number of topics on any number of channels,
 * the client may only hold a single subscription for each unique topic at any
 * given time. When attempting to create a duplicate subscription,
 * the server will close the existing channel, log a warning, and
 * spawn a new channel for the topic. The client will have their
 * `channel.onClose` callbacks fired for the existing channel, and the new
 * channel join will have its receive hooks processed as normal.
 *
 * ## Pushing Messages
 *
 * From the previous example, we can see that pushing messages to the server
 * can be done with `channel.push(eventName, payload)` and we can optionally
 * receive responses from the push. Additionally, we can use
 * `receive("timeout", callback)` to abort waiting for our other `receive` hooks
 *  and take action after some period of waiting. The default timeout is 10000ms.
 *
 *
 * ## Socket Hooks
 *
 * Lifecycle events of the multiplexed connection can be hooked into via
 * `socket.onError()` and `socket.onClose()` events, ie:
 *
 * ```javascript
 * socket.onError( () => console.log("there was an error with the connection!") )
 * socket.onClose( () => console.log("the connection dropped") )
 * ```
 *
 *
 * ## Channel Hooks
 *
 * For each joined channel, you can bind to `onError` and `onClose` events
 * to monitor the channel lifecycle, ie:
 *
 * ```javascript
 * channel.onError( () => console.log("there was an error!") )
 * channel.onClose( () => console.log("the channel has gone away gracefully") )
 * ```
 *
 * ### onError hooks
 *
 * `onError` hooks are invoked if the socket connection drops, or the channel
 * crashes on the server. In either case, a channel rejoin is attempted
 * automatically in an exponential backoff manner.
 *
 * ### onClose hooks
 *
 * `onClose` hooks are invoked only in two cases. 1) the channel explicitly
 * closed on the server, or 2). The client explicitly closed, by calling
 * `channel.leave()`
 *
 *
 * ## Presence
 *
 * The `Presence` object provides features for syncing presence information
 * from the server with the client and handling presences joining and leaving.
 *
 * ### Syncing state from the server
 *
 * To sync presence state from the server, first instantiate an object and
 * pass your channel in to track lifecycle events:
 *
 * ```javascript
 * let channel = socket.channel("some:topic")
 * let presence = new Presence(channel)
 * ```
 *
 * Next, use the `presence.onSync` callback to react to state changes
 * from the server. For example, to render the list of users every time
 * the list changes, you could write:
 *
 * ```javascript
 * presence.onSync(() => {
 *   myRenderUsersFunction(presence.list())
 * })
 * ```
 *
 * ### Listing Presences
 *
 * `presence.list` is used to return a list of presence information
 * based on the local state of metadata. By default, all presence
 * metadata is returned, but a `listBy` function can be supplied to
 * allow the client to select which metadata to use for a given presence.
 * For example, you may have a user online from different devices with
 * a metadata status of "online", but they have set themselves to "away"
 * on another device. In this case, the app may choose to use the "away"
 * status for what appears on the UI. The example below defines a `listBy`
 * function which prioritizes the first metadata which was registered for
 * each user. This could be the first tab they opened, or the first device
 * they came online from:
 *
 * ```javascript
 * let listBy = (id, {metas: [first, ...rest]}) => {
 *   first.count = rest.length + 1 // count of this user's presences
 *   first.id = id
 *   return first
 * }
 * let onlineUsers = presence.list(listBy)
 * ```
 *
 * ### Handling individual presence join and leave events
 *
 * The `presence.onJoin` and `presence.onLeave` callbacks can be used to
 * react to individual presences joining and leaving the app. For example:
 *
 * ```javascript
 * let presence = new Presence(channel)
 *
 * // detect if user has joined for the 1st time or from another tab/device
 * presence.onJoin((id, current, newPres) => {
 *   if(!current){
 *     console.log("user has entered for the first time", newPres)
 *   } else {
 *     console.log("user additional presence", newPres)
 *   }
 * })
 *
 * // detect if user has left from all tabs/devices, or is still present
 * presence.onLeave((id, current, leftPres) => {
 *   if(current.metas.length === 0){
 *     console.log("user has left from all devices", leftPres)
 *   } else {
 *     console.log("user left from a device", leftPres)
 *   }
 * })
 * // receive presence data from server
 * presence.onSync(() => {
 *   displayUsers(presence.list())
 * })
 * ```
 * @module phoenix
 */
var globalSelf = typeof self !== "undefined" ? self : null;
var phxWindow = typeof window !== "undefined" ? window : null;
var global = globalSelf || phxWindow || void 0;
var DEFAULT_VSN = "2.0.0";
var SOCKET_STATES = {
    connecting: 0,
    open: 1,
    closing: 2,
    closed: 3
};
var DEFAULT_TIMEOUT = 10000;
var WS_CLOSE_NORMAL = 1000;
var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
};
var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
};
var CHANNEL_LIFECYCLE_EVENTS = [CHANNEL_EVENTS.close, CHANNEL_EVENTS.error, CHANNEL_EVENTS.join, CHANNEL_EVENTS.reply, CHANNEL_EVENTS.leave];
var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
}; // wraps value in closure or returns closure

var closure = function closure(value) {
    if (typeof value === "function") {
        return value;
    } else {
        var _closure = function _closure() {
            return value;
        };

        return _closure;
    }
};
/**
 * Initializes the Push
 * @param {Channel} channel - The Channel
 * @param {string} event - The event, for example `"phx_join"`
 * @param {Object} payload - The payload, for example `{user_id: 123}`
 * @param {number} timeout - The push timeout in milliseconds
 */


var Push = /*#__PURE__*/function () {
    function Push(channel, event, payload, timeout) {
        _classCallCheck(this, Push);

        this.channel = channel;
        this.event = event;

        this.payload = payload || function () {
            return {};
        };

        this.receivedResp = null;
        this.timeout = timeout;
        this.timeoutTimer = null;
        this.recHooks = [];
        this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */


    _createClass(Push, [{
        key: "resend",
        value: function resend(timeout) {
            this.timeout = timeout;
            this.reset();
            this.send();
        }
        /**
         *
         */

    }, {
        key: "send",
        value: function send() {
            if (this.hasReceived("timeout")) {
                return;
            }

            this.startTimeout();
            this.sent = true;
            this.channel.socket.push({
                topic: this.channel.topic,
                event: this.event,
                payload: this.payload(),
                ref: this.ref,
                join_ref: this.channel.joinRef()
            });
        }
        /**
         *
         * @param {*} status
         * @param {*} callback
         */

    }, {
        key: "receive",
        value: function receive(status, callback) {
            if (this.hasReceived(status)) {
                callback(this.receivedResp.response);
            }

            this.recHooks.push({
                status: status,
                callback: callback
            });
            return this;
        }
        /**
         * @private
         */

    }, {
        key: "reset",
        value: function reset() {
            this.cancelRefEvent();
            this.ref = null;
            this.refEvent = null;
            this.receivedResp = null;
            this.sent = false;
        }
        /**
         * @private
         */

    }, {
        key: "matchReceive",
        value: function matchReceive(_ref) {
            var status = _ref.status,
                response = _ref.response,
                ref = _ref.ref;
            this.recHooks.filter(function (h) {
                return h.status === status;
            }).forEach(function (h) {
                return h.callback(response);
            });
        }
        /**
         * @private
         */

    }, {
        key: "cancelRefEvent",
        value: function cancelRefEvent() {
            if (!this.refEvent) {
                return;
            }

            this.channel.off(this.refEvent);
        }
        /**
         * @private
         */

    }, {
        key: "cancelTimeout",
        value: function cancelTimeout() {
            clearTimeout(this.timeoutTimer);
            this.timeoutTimer = null;
        }
        /**
         * @private
         */

    }, {
        key: "startTimeout",
        value: function startTimeout() {
            var _this = this;

            if (this.timeoutTimer) {
                this.cancelTimeout();
            }

            this.ref = this.channel.socket.makeRef();
            this.refEvent = this.channel.replyEventName(this.ref);
            this.channel.on(this.refEvent, function (payload) {
                _this.cancelRefEvent();

                _this.cancelTimeout();

                _this.receivedResp = payload;

                _this.matchReceive(payload);
            });
            this.timeoutTimer = setTimeout(function () {
                _this.trigger("timeout", {});
            }, this.timeout);
        }
        /**
         * @private
         */

    }, {
        key: "hasReceived",
        value: function hasReceived(status) {
            return this.receivedResp && this.receivedResp.status === status;
        }
        /**
         * @private
         */

    }, {
        key: "trigger",
        value: function trigger(status, response) {
            this.channel.trigger(this.refEvent, {
                status: status,
                response: response
            });
        }
    }]);

    return Push;
}();
/**
 *
 * @param {string} topic
 * @param {(Object|function)} params
 * @param {Socket} socket
 */


var Channel = /*#__PURE__*/function () {
    function Channel(topic, params, socket) {
        var _this2 = this;

        _classCallCheck(this, Channel);

        this.state = CHANNEL_STATES.closed;
        this.topic = topic;
        this.params = closure(params || {});
        this.socket = socket;
        this.bindings = [];
        this.bindingRef = 0;
        this.timeout = this.socket.timeout;
        this.joinedOnce = false;
        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
        this.pushBuffer = [];
        this.stateChangeRefs = [];
        this.rejoinTimer = new Timer(function () {
            if (_this2.socket.isConnected()) {
                _this2.rejoin();
            }
        }, this.socket.rejoinAfterMs);
        this.stateChangeRefs.push(this.socket.onError(function () {
            return _this2.rejoinTimer.reset();
        }));
        this.stateChangeRefs.push(this.socket.onOpen(function () {
            _this2.rejoinTimer.reset();

            if (_this2.isErrored()) {
                _this2.rejoin();
            }
        }));
        this.joinPush.receive("ok", function () {
            _this2.state = CHANNEL_STATES.joined;

            _this2.rejoinTimer.reset();

            _this2.pushBuffer.forEach(function (pushEvent) {
                return pushEvent.send();
            });

            _this2.pushBuffer = [];
        });
        this.joinPush.receive("error", function () {
            _this2.state = CHANNEL_STATES.errored;

            if (_this2.socket.isConnected()) {
                _this2.rejoinTimer.scheduleTimeout();
            }
        });
        this.onClose(function () {
            _this2.rejoinTimer.reset();

            if (_this2.socket.hasLogger()) _this2.socket.log("channel", "close ".concat(_this2.topic, " ").concat(_this2.joinRef()));
            _this2.state = CHANNEL_STATES.closed;

            _this2.socket.remove(_this2);
        });
        this.onError(function (reason) {
            if (_this2.socket.hasLogger()) _this2.socket.log("channel", "error ".concat(_this2.topic), reason);

            if (_this2.isJoining()) {
                _this2.joinPush.reset();
            }

            _this2.state = CHANNEL_STATES.errored;

            if (_this2.socket.isConnected()) {
                _this2.rejoinTimer.scheduleTimeout();
            }
        });
        this.joinPush.receive("timeout", function () {
            if (_this2.socket.hasLogger()) _this2.socket.log("channel", "timeout ".concat(_this2.topic, " (").concat(_this2.joinRef(), ")"), _this2.joinPush.timeout);
            var leavePush = new Push(_this2, CHANNEL_EVENTS.leave, closure({}), _this2.timeout);
            leavePush.send();
            _this2.state = CHANNEL_STATES.errored;

            _this2.joinPush.reset();

            if (_this2.socket.isConnected()) {
                _this2.rejoinTimer.scheduleTimeout();
            }
        });
        this.on(CHANNEL_EVENTS.reply, function (payload, ref) {
            _this2.trigger(_this2.replyEventName(ref), payload);
        });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */


    _createClass(Channel, [{
        key: "join",
        value: function join() {
            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;

            if (this.joinedOnce) {
                throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
            } else {
                this.timeout = timeout;
                this.joinedOnce = true;
                this.rejoin();
                return this.joinPush;
            }
        }
        /**
         * Hook into channel close
         * @param {Function} callback
         */

    }, {
        key: "onClose",
        value: function onClose(callback) {
            this.on(CHANNEL_EVENTS.close, callback);
        }
        /**
         * Hook into channel errors
         * @param {Function} callback
         */

    }, {
        key: "onError",
        value: function onError(callback) {
            return this.on(CHANNEL_EVENTS.error, function (reason) {
                return callback(reason);
            });
        }
        /**
         * Subscribes on channel events
         *
         * Subscription returns a ref counter, which can be used later to
         * unsubscribe the exact event listener
         *
         * @example
         * const ref1 = channel.on("event", do_stuff)
         * const ref2 = channel.on("event", do_other_stuff)
         * channel.off("event", ref1)
         * // Since unsubscription, do_stuff won't fire,
         * // while do_other_stuff will keep firing on the "event"
         *
         * @param {string} event
         * @param {Function} callback
         * @returns {integer} ref
         */

    }, {
        key: "on",
        value: function on(event, callback) {
            var ref = this.bindingRef++;
            this.bindings.push({
                event: event,
                ref: ref,
                callback: callback
            });
            return ref;
        }
        /**
         * Unsubscribes off of channel events
         *
         * Use the ref returned from a channel.on() to unsubscribe one
         * handler, or pass nothing for the ref to unsubscribe all
         * handlers for the given event.
         *
         * @example
         * // Unsubscribe the do_stuff handler
         * const ref1 = channel.on("event", do_stuff)
         * channel.off("event", ref1)
         *
         * // Unsubscribe all handlers from event
         * channel.off("event")
         *
         * @param {string} event
         * @param {integer} ref
         */

    }, {
        key: "off",
        value: function off(event, ref) {
            this.bindings = this.bindings.filter(function (bind) {
                return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
            });
        }
        /**
         * @private
         */

    }, {
        key: "canPush",
        value: function canPush() {
            return this.socket.isConnected() && this.isJoined();
        }
        /**
         * Sends a message `event` to phoenix with the payload `payload`.
         * Phoenix receives this in the `handle_in(event, payload, socket)`
         * function. if phoenix replies or it times out (default 10000ms),
         * then optionally the reply can be received.
         *
         * @example
         * channel.push("event")
         *   .receive("ok", payload => console.log("phoenix replied:", payload))
         *   .receive("error", err => console.log("phoenix errored", err))
         *   .receive("timeout", () => console.log("timed out pushing"))
         * @param {string} event
         * @param {Object} payload
         * @param {number} [timeout]
         * @returns {Push}
         */

    }, {
        key: "push",
        value: function push(event, payload) {
            var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;

            if (!this.joinedOnce) {
                throw new Error("tried to push '".concat(event, "' to '").concat(this.topic, "' before joining. Use channel.join() before pushing events"));
            }

            var pushEvent = new Push(this, event, function () {
                return payload;
            }, timeout);

            if (this.canPush()) {
                pushEvent.send();
            } else {
                pushEvent.startTimeout();
                this.pushBuffer.push(pushEvent);
            }

            return pushEvent;
        }
        /** Leaves the channel
         *
         * Unsubscribes from server events, and
         * instructs channel to terminate on server
         *
         * Triggers onClose() hooks
         *
         * To receive leave acknowledgements, use the `receive`
         * hook to bind to the server ack, ie:
         *
         * @example
         * channel.leave().receive("ok", () => alert("left!") )
         *
         * @param {integer} timeout
         * @returns {Push}
         */

    }, {
        key: "leave",
        value: function leave() {
            var _this3 = this;

            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;
            this.rejoinTimer.reset();
            this.joinPush.cancelTimeout();
            this.state = CHANNEL_STATES.leaving;

            var onClose = function onClose() {
                if (_this3.socket.hasLogger()) _this3.socket.log("channel", "leave ".concat(_this3.topic));

                _this3.trigger(CHANNEL_EVENTS.close, "leave");
            };

            var leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
            leavePush.receive("ok", function () {
                return onClose();
            }).receive("timeout", function () {
                return onClose();
            });
            leavePush.send();

            if (!this.canPush()) {
                leavePush.trigger("ok", {});
            }

            return leavePush;
        }
        /**
         * Overridable message hook
         *
         * Receives all events for specialized message handling
         * before dispatching to the channel callbacks.
         *
         * Must return the payload, modified or unmodified
         * @param {string} event
         * @param {Object} payload
         * @param {integer} ref
         * @returns {Object}
         */

    }, {
        key: "onMessage",
        value: function onMessage(event, payload, ref) {
            return payload;
        }
        /**
         * @private
         */

    }, {
        key: "isLifecycleEvent",
        value: function isLifecycleEvent(event) {
            return CHANNEL_LIFECYCLE_EVENTS.indexOf(event) >= 0;
        }
        /**
         * @private
         */

    }, {
        key: "isMember",
        value: function isMember(topic, event, payload, joinRef) {
            if (this.topic !== topic) {
                return false;
            }

            if (joinRef && joinRef !== this.joinRef() && this.isLifecycleEvent(event)) {
                if (this.socket.hasLogger()) this.socket.log("channel", "dropping outdated message", {
                    topic: topic,
                    event: event,
                    payload: payload,
                    joinRef: joinRef
                });
                return false;
            } else {
                return true;
            }
        }
        /**
         * @private
         */

    }, {
        key: "joinRef",
        value: function joinRef() {
            return this.joinPush.ref;
        }
        /**
         * @private
         */

    }, {
        key: "rejoin",
        value: function rejoin() {
            var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;

            if (this.isLeaving()) {
                return;
            }

            this.socket.leaveOpenTopic(this.topic);
            this.state = CHANNEL_STATES.joining;
            this.joinPush.resend(timeout);
        }
        /**
         * @private
         */

    }, {
        key: "trigger",
        value: function trigger(event, payload, ref, joinRef) {
            var handledPayload = this.onMessage(event, payload, ref, joinRef);

            if (payload && !handledPayload) {
                throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
            }

            var eventBindings = this.bindings.filter(function (bind) {
                return bind.event === event;
            });

            for (var i = 0; i < eventBindings.length; i++) {
                var bind = eventBindings[i];
                bind.callback(handledPayload, ref, joinRef || this.joinRef());
            }
        }
        /**
         * @private
         */

    }, {
        key: "replyEventName",
        value: function replyEventName(ref) {
            return "chan_reply_".concat(ref);
        }
        /**
         * @private
         */

    }, {
        key: "isClosed",
        value: function isClosed() {
            return this.state === CHANNEL_STATES.closed;
        }
        /**
         * @private
         */

    }, {
        key: "isErrored",
        value: function isErrored() {
            return this.state === CHANNEL_STATES.errored;
        }
        /**
         * @private
         */

    }, {
        key: "isJoined",
        value: function isJoined() {
            return this.state === CHANNEL_STATES.joined;
        }
        /**
         * @private
         */

    }, {
        key: "isJoining",
        value: function isJoining() {
            return this.state === CHANNEL_STATES.joining;
        }
        /**
         * @private
         */

    }, {
        key: "isLeaving",
        value: function isLeaving() {
            return this.state === CHANNEL_STATES.leaving;
        }
    }]);

    return Channel;
}();
/* The default serializer for encoding and decoding messages */


exports.Channel = Channel;
var Serializer = {
    encode: function encode(msg, callback) {
        var payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback(JSON.stringify(payload));
    },
    decode: function decode(rawPayload, callback) {
        var _JSON$parse = JSON.parse(rawPayload),
            _JSON$parse2 = _slicedToArray(_JSON$parse, 5),
            join_ref = _JSON$parse2[0],
            ref = _JSON$parse2[1],
            topic = _JSON$parse2[2],
            event = _JSON$parse2[3],
            payload = _JSON$parse2[4];

        return callback({
            join_ref: join_ref,
            ref: ref,
            topic: topic,
            event: event,
            payload: payload
        });
    }
};
/** Initializes the Socket
 *
 *
 * For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)
 *
 * @param {string} endPoint - The string WebSocket endpoint, ie, `"ws://example.com/socket"`,
 *                                               `"wss://example.com"`
 *                                               `"/socket"` (inherited host & protocol)
 * @param {Object} [opts] - Optional configuration
 * @param {string} [opts.transport] - The Websocket Transport, for example WebSocket or Phoenix.LongPoll.
 *
 * Defaults to WebSocket with automatic LongPoll fallback.
 * @param {Function} [opts.encode] - The function to encode outgoing messages.
 *
 * Defaults to JSON encoder.
 *
 * @param {Function} [opts.decode] - The function to decode incoming messages.
 *
 * Defaults to JSON:
 *
 * ```javascript
 * (payload, callback) => callback(JSON.parse(payload))
 * ```
 *
 * @param {number} [opts.timeout] - The default timeout in milliseconds to trigger push timeouts.
 *
 * Defaults `DEFAULT_TIMEOUT`
 * @param {number} [opts.heartbeatIntervalMs] - The millisec interval to send a heartbeat message
 * @param {number} [opts.reconnectAfterMs] - The optional function that returns the millsec
 * socket reconnect interval.
 *
 * Defaults to stepped backoff of:
 *
 * ```javascript
 * function(tries){
 *   return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000
 * }
 * ````
 *
 * @param {number} [opts.rejoinAfterMs] - The optional function that returns the millsec
 * rejoin interval for individual channels.
 *
 * ```javascript
 * function(tries){
 *   return [1000, 2000, 5000][tries - 1] || 10000
 * }
 * ````
 *
 * @param {Function} [opts.logger] - The optional function for specialized logging, ie:
 *
 * ```javascript
 * function(kind, msg, data) {
 *   console.log(`${kind}: ${msg}`, data)
 * }
 * ```
 *
 * @param {number} [opts.longpollerTimeout] - The maximum timeout of a long poll AJAX request.
 *
 * Defaults to 20s (double the server long poll timer).
 *
 * @param {{Object|function)} [opts.params] - The optional params to pass when connecting
 * @param {string} [opts.binaryType] - The binary type to use for binary WebSocket frames.
 *
 * Defaults to "arraybuffer"
 *
 * @param {vsn} [opts.vsn] - The serializer's protocol version to send on connect.
 *
 * Defaults to DEFAULT_VSN.
*/

exports.Serializer = Serializer;

var Socket = /*#__PURE__*/function () {
    function Socket(endPoint) {
        var _this4 = this;

        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Socket);

        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        };
        this.channels = [];
        this.sendBuffer = [];
        this.ref = 0;
        this.timeout = opts.timeout || DEFAULT_TIMEOUT;
        this.transport = opts.transport || global.WebSocket || LongPoll;
        this.defaultEncoder = Serializer.encode;
        this.defaultDecoder = Serializer.decode;
        this.closeWasClean = false;
        this.unloaded = false;
        this.binaryType = opts.binaryType || "arraybuffer";

        if (this.transport !== LongPoll) {
            this.encode = opts.encode || this.defaultEncoder;
            this.decode = opts.decode || this.defaultDecoder;
        } else {
            this.encode = this.defaultEncoder;
            this.decode = this.defaultDecoder;
        }

        if (phxWindow && phxWindow.addEventListener) {
            phxWindow.addEventListener("unload", function (e) {
                if (_this4.conn) {
                    _this4.unloaded = true;

                    _this4.abnormalClose("unloaded");
                }
            });
        }

        this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;

        this.rejoinAfterMs = function (tries) {
            if (opts.rejoinAfterMs) {
                return opts.rejoinAfterMs(tries);
            } else {
                return [1000, 2000, 5000][tries - 1] || 10000;
            }
        };

        this.reconnectAfterMs = function (tries) {
            if (_this4.unloaded) {
                return 100;
            }

            if (opts.reconnectAfterMs) {
                return opts.reconnectAfterMs(tries);
            } else {
                return [10, 50, 100, 150, 200, 250, 500, 1000, 2000][tries - 1] || 5000;
            }
        };

        this.logger = opts.logger || null;
        this.longpollerTimeout = opts.longpollerTimeout || 20000;
        this.params = closure(opts.params || {});
        this.endPoint = "".concat(endPoint, "/").concat(TRANSPORTS.websocket);
        this.vsn = opts.vsn || DEFAULT_VSN;
        this.heartbeatTimer = null;
        this.pendingHeartbeatRef = null;
        this.reconnectTimer = new Timer(function () {
            _this4.teardown(function () {
                return _this4.connect();
            });
        }, this.reconnectAfterMs);
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */


    _createClass(Socket, [{
        key: "protocol",
        value: function protocol() {
            return location.protocol.match(/^https/) ? "wss" : "ws";
        }
        /**
         * The fully qualifed socket url
         *
         * @returns {string}
         */

    }, {
        key: "endPointURL",
        value: function endPointURL() {
            var uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {
                vsn: this.vsn
            });

            if (uri.charAt(0) !== "/") {
                return uri;
            }

            if (uri.charAt(1) === "/") {
                return "".concat(this.protocol(), ":").concat(uri);
            }

            return "".concat(this.protocol(), "://").concat(location.host).concat(uri);
        }
        /**
         * Disconnects the socket
         *
         * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
         *
         * @param {Function} callback - Optional callback which is called after socket is disconnected.
         * @param {integer} code - A status code for disconnection (Optional).
         * @param {string} reason - A textual description of the reason to disconnect. (Optional)
         */

    }, {
        key: "disconnect",
        value: function disconnect(callback, code, reason) {
            this.closeWasClean = true;
            this.reconnectTimer.reset();
            this.teardown(callback, code, reason);
        }
        /**
         *
         * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
         *
         * Passing params to connect is deprecated; pass them in the Socket constructor instead:
         * `new Socket("/socket", {params: {user_id: userToken}})`.
         */

    }, {
        key: "connect",
        value: function connect(params) {
            var _this5 = this;

            if (params) {
                console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
                this.params = closure(params);
            }

            if (this.conn) {
                return;
            }

            this.closeWasClean = false;
            this.conn = new this.transport(this.endPointURL());
            this.conn.binaryType = this.binaryType;
            this.conn.timeout = this.longpollerTimeout;

            this.conn.onopen = function () {
                return _this5.onConnOpen();
            };

            this.conn.onerror = function (error) {
                return _this5.onConnError(error);
            };

            this.conn.onmessage = function (event) {
                return _this5.onConnMessage(event);
            };

            this.conn.onclose = function (event) {
                return _this5.onConnClose(event);
            };
        }
        /**
         * Logs the message. Override `this.logger` for specialized logging. noops by default
         * @param {string} kind
         * @param {string} msg
         * @param {Object} data
         */

    }, {
        key: "log",
        value: function log(kind, msg, data) {
            this.logger(kind, msg, data);
        }
        /**
         * Returns true if a logger has been set on this socket.
         */

    }, {
        key: "hasLogger",
        value: function hasLogger() {
            return this.logger !== null;
        }
        /**
         * Registers callbacks for connection open events
         *
         * @example socket.onOpen(function(){ console.info("the socket was opened") })
         *
         * @param {Function} callback
         */

    }, {
        key: "onOpen",
        value: function onOpen(callback) {
            var ref = this.makeRef();
            this.stateChangeCallbacks.open.push([ref, callback]);
            return ref;
        }
        /**
         * Registers callbacks for connection close events
         * @param {Function} callback
         */

    }, {
        key: "onClose",
        value: function onClose(callback) {
            var ref = this.makeRef();
            this.stateChangeCallbacks.close.push([ref, callback]);
            return ref;
        }
        /**
         * Registers callbacks for connection error events
         *
         * @example socket.onError(function(error){ alert("An error occurred") })
         *
         * @param {Function} callback
         */

    }, {
        key: "onError",
        value: function onError(callback) {
            var ref = this.makeRef();
            this.stateChangeCallbacks.error.push([ref, callback]);
            return ref;
        }
        /**
         * Registers callbacks for connection message events
         * @param {Function} callback
         */

    }, {
        key: "onMessage",
        value: function onMessage(callback) {
            var ref = this.makeRef();
            this.stateChangeCallbacks.message.push([ref, callback]);
            return ref;
        }
        /**
         * @private
         */

    }, {
        key: "onConnOpen",
        value: function onConnOpen() {
            if (this.hasLogger()) this.log("transport", "connected to ".concat(this.endPointURL()));
            this.unloaded = false;
            this.closeWasClean = false;
            this.flushSendBuffer();
            this.reconnectTimer.reset();
            this.resetHeartbeat();
            this.stateChangeCallbacks.open.forEach(function (_ref2) {
                var _ref3 = _slicedToArray(_ref2, 2),
                    callback = _ref3[1];

                return callback();
            });
        }
        /**
         * @private
         */

    }, {
        key: "resetHeartbeat",
        value: function resetHeartbeat() {
            var _this6 = this;

            if (this.conn && this.conn.skipHeartbeat) {
                return;
            }

            this.pendingHeartbeatRef = null;
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = setInterval(function () {
                return _this6.sendHeartbeat();
            }, this.heartbeatIntervalMs);
        }
    }, {
        key: "teardown",
        value: function teardown(callback, code, reason) {
            var _this7 = this;

            if (!this.conn) {
                return callback && callback();
            }

            this.waitForBufferDone(function () {
                if (_this7.conn) {
                    if (code) {
                        _this7.conn.close(code, reason || "");
                    } else {
                        _this7.conn.close();
                    }
                }

                _this7.waitForSocketClosed(function () {
                    if (_this7.conn) {
                        _this7.conn.onclose = function () { }; // noop


                        _this7.conn = null;
                    }

                    callback && callback();
                });
            });
        }
    }, {
        key: "waitForBufferDone",
        value: function waitForBufferDone(callback) {
            var _this8 = this;

            var tries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
                callback();
                return;
            }

            setTimeout(function () {
                _this8.waitForBufferDone(callback, tries + 1);
            }, 150 * tries);
        }
    }, {
        key: "waitForSocketClosed",
        value: function waitForSocketClosed(callback) {
            var _this9 = this;

            var tries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

            if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
                callback();
                return;
            }

            setTimeout(function () {
                _this9.waitForSocketClosed(callback, tries + 1);
            }, 150 * tries);
        }
    }, {
        key: "onConnClose",
        value: function onConnClose(event) {
            if (this.hasLogger()) this.log("transport", "close", event);
            this.triggerChanError();
            clearInterval(this.heartbeatTimer);

            if (!this.closeWasClean) {
                this.reconnectTimer.scheduleTimeout();
            }

            this.stateChangeCallbacks.close.forEach(function (_ref4) {
                var _ref5 = _slicedToArray(_ref4, 2),
                    callback = _ref5[1];

                return callback(event);
            });
        }
        /**
         * @private
         */

    }, {
        key: "onConnError",
        value: function onConnError(error) {
            if (this.hasLogger()) this.log("transport", error);
            this.triggerChanError();
            this.stateChangeCallbacks.error.forEach(function (_ref6) {
                var _ref7 = _slicedToArray(_ref6, 2),
                    callback = _ref7[1];

                return callback(error);
            });
        }
        /**
         * @private
         */

    }, {
        key: "triggerChanError",
        value: function triggerChanError() {
            this.channels.forEach(function (channel) {
                if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
                    channel.trigger(CHANNEL_EVENTS.error);
                }
            });
        }
        /**
         * @returns {string}
         */

    }, {
        key: "connectionState",
        value: function connectionState() {
            switch (this.conn && this.conn.readyState) {
                case SOCKET_STATES.connecting:
                    return "connecting";

                case SOCKET_STATES.open:
                    return "open";

                case SOCKET_STATES.closing:
                    return "closing";

                default:
                    return "closed";
            }
        }
        /**
         * @returns {boolean}
         */

    }, {
        key: "isConnected",
        value: function isConnected() {
            return this.connectionState() === "open";
        }
        /**
         * @private
         *
         * @param {Channel}
         */

    }, {
        key: "remove",
        value: function remove(channel) {
            this.off(channel.stateChangeRefs);
            this.channels = this.channels.filter(function (c) {
                return c.joinRef() !== channel.joinRef();
            });
        }
        /**
         * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
         *
         * @param {refs} - list of refs returned by calls to
         *                 `onOpen`, `onClose`, `onError,` and `onMessage`
         */

    }, {
        key: "off",
        value: function off(refs) {
            for (var key in this.stateChangeCallbacks) {
                this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(function (_ref8) {
                    var _ref9 = _slicedToArray(_ref8, 1),
                        ref = _ref9[0];

                    return refs.indexOf(ref) === -1;
                });
            }
        }
        /**
         * Initiates a new channel for the given topic
         *
         * @param {string} topic
         * @param {Object} chanParams - Parameters for the channel
         * @returns {Channel}
         */

    }, {
        key: "channel",
        value: function channel(topic) {
            var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var chan = new Channel(topic, chanParams, this);
            this.channels.push(chan);
            return chan;
        }
        /**
         * @param {Object} data
         */

    }, {
        key: "push",
        value: function push(data) {
            var _this10 = this;

            if (this.hasLogger()) {
                var topic = data.topic,
                    event = data.event,
                    payload = data.payload,
                    ref = data.ref,
                    join_ref = data.join_ref;
                this.log("push", "".concat(topic, " ").concat(event, " (").concat(join_ref, ", ").concat(ref, ")"), payload);
            }

            if (this.isConnected()) {
                this.encode(data, function (result) {
                    return _this10.conn.send(result);
                });
            } else {
                this.sendBuffer.push(function () {
                    return _this10.encode(data, function (result) {
                        return _this10.conn.send(result);
                    });
                });
            }
        }
        /**
         * Return the next message ref, accounting for overflows
         * @returns {string}
         */

    }, {
        key: "makeRef",
        value: function makeRef() {
            var newRef = this.ref + 1;

            if (newRef === this.ref) {
                this.ref = 0;
            } else {
                this.ref = newRef;
            }

            return this.ref.toString();
        }
    }, {
        key: "sendHeartbeat",
        value: function sendHeartbeat() {
            if (!this.isConnected()) {
                return;
            }

            if (this.pendingHeartbeatRef) {
                this.pendingHeartbeatRef = null;
                if (this.hasLogger()) this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
                this.abnormalClose("heartbeat timeout");
                return;
            }

            this.pendingHeartbeatRef = this.makeRef();
            this.push({
                topic: "phoenix",
                event: "heartbeat",
                payload: {},
                ref: this.pendingHeartbeatRef
            });
        }
    }, {
        key: "abnormalClose",
        value: function abnormalClose(reason) {
            this.closeWasClean = false;
            this.conn.close(WS_CLOSE_NORMAL, reason);
        }
    }, {
        key: "flushSendBuffer",
        value: function flushSendBuffer() {
            if (this.isConnected() && this.sendBuffer.length > 0) {
                this.sendBuffer.forEach(function (callback) {
                    return callback();
                });
                this.sendBuffer = [];
            }
        }
    }, {
        key: "onConnMessage",
        value: function onConnMessage(rawMessage) {
            var _this11 = this;

            this.decode(rawMessage.data, function (msg) {
                var topic = msg.topic,
                    event = msg.event,
                    payload = msg.payload,
                    ref = msg.ref,
                    join_ref = msg.join_ref;

                if (ref && ref === _this11.pendingHeartbeatRef) {
                    _this11.pendingHeartbeatRef = null;
                }

                if (_this11.hasLogger()) _this11.log("receive", "".concat(payload.status || "", " ").concat(topic, " ").concat(event, " ").concat(ref && "(" + ref + ")" || ""), payload);

                for (var i = 0; i < _this11.channels.length; i++) {
                    var channel = _this11.channels[i];

                    if (!channel.isMember(topic, event, payload, join_ref)) {
                        continue;
                    }

                    channel.trigger(event, payload, ref, join_ref);
                }

                for (var _i2 = 0; _i2 < _this11.stateChangeCallbacks.message.length; _i2++) {
                    var _this11$stateChangeCa = _slicedToArray(_this11.stateChangeCallbacks.message[_i2], 2),
                        callback = _this11$stateChangeCa[1];

                    callback(msg);
                }
            });
        }
    }, {
        key: "leaveOpenTopic",
        value: function leaveOpenTopic(topic) {
            var dupChannel = this.channels.find(function (c) {
                return c.topic === topic && (c.isJoined() || c.isJoining());
            });

            if (dupChannel) {
                if (this.hasLogger()) this.log("transport", "leaving duplicate topic \"".concat(topic, "\""));
                dupChannel.leave();
            }
        }
    }]);

    return Socket;
}();

exports.Socket = Socket;

var LongPoll = /*#__PURE__*/function () {
    function LongPoll(endPoint) {
        _classCallCheck(this, LongPoll);

        this.endPoint = null;
        this.token = null;
        this.skipHeartbeat = true;

        this.onopen = function () { }; // noop


        this.onerror = function () { }; // noop


        this.onmessage = function () { }; // noop


        this.onclose = function () { }; // noop


        this.pollEndpoint = this.normalizeEndpoint(endPoint);
        this.readyState = SOCKET_STATES.connecting;
        this.poll();
    }

    _createClass(LongPoll, [{
        key: "normalizeEndpoint",
        value: function normalizeEndpoint(endPoint) {
            return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)\/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
        }
    }, {
        key: "endpointURL",
        value: function endpointURL() {
            return Ajax.appendParams(this.pollEndpoint, {
                token: this.token
            });
        }
    }, {
        key: "closeAndRetry",
        value: function closeAndRetry() {
            this.close();
            this.readyState = SOCKET_STATES.connecting;
        }
    }, {
        key: "ontimeout",
        value: function ontimeout() {
            this.onerror("timeout");
            this.closeAndRetry();
        }
    }, {
        key: "poll",
        value: function poll() {
            var _this12 = this;

            if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {
                return;
            }

            Ajax.request("GET", this.endpointURL(), "application/json", null, this.timeout, this.ontimeout.bind(this), function (resp) {
                if (resp) {
                    var status = resp.status,
                        token = resp.token,
                        messages = resp.messages;
                    _this12.token = token;
                } else {
                    var status = 0;
                }

                switch (status) {
                    case 200:
                        messages.forEach(function (msg) {
                            return _this12.onmessage({
                                data: msg
                            });
                        });

                        _this12.poll();

                        break;

                    case 204:
                        _this12.poll();

                        break;

                    case 410:
                        _this12.readyState = SOCKET_STATES.open;

                        _this12.onopen();

                        _this12.poll();

                        break;

                    case 403:
                        _this12.onerror();

                        _this12.close();

                        break;

                    case 0:
                    case 500:
                        _this12.onerror();

                        _this12.closeAndRetry();

                        break;

                    default:
                        throw new Error("unhandled poll status ".concat(status));
                }
            });
        }
    }, {
        key: "send",
        value: function send(body) {
            var _this13 = this;

            Ajax.request("POST", this.endpointURL(), "application/json", body, this.timeout, this.onerror.bind(this, "timeout"), function (resp) {
                if (!resp || resp.status !== 200) {
                    _this13.onerror(resp && resp.status);

                    _this13.closeAndRetry();
                }
            });
        }
    }, {
        key: "close",
        value: function close(code, reason) {
            this.readyState = SOCKET_STATES.closed;
            this.onclose();
        }
    }]);

    return LongPoll;
}();

exports.LongPoll = LongPoll;

var Ajax = /*#__PURE__*/function () {
    function Ajax() {
        _classCallCheck(this, Ajax);
    }

    _createClass(Ajax, null, [{
        key: "request",
        value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {
            if (global.XDomainRequest) {
                var req = new XDomainRequest(); // IE8, IE9

                this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);
            } else {
                var _req = new global.XMLHttpRequest(); // IE7+, Firefox, Chrome, Opera, Safari


                this.xhrRequest(_req, method, endPoint, accept, body, timeout, ontimeout, callback);
            }
        }
    }, {
        key: "xdomainRequest",
        value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {
            var _this14 = this;

            req.timeout = timeout;
            req.open(method, endPoint);

            req.onload = function () {
                var response = _this14.parseJSON(req.responseText);

                callback && callback(response);
            };

            if (ontimeout) {
                req.ontimeout = ontimeout;
            } // Work around bug in IE9 that requires an attached onprogress handler


            req.onprogress = function () { };

            req.send(body);
        }
    }, {
        key: "xhrRequest",
        value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {
            var _this15 = this;

            req.open(method, endPoint, true);
            req.timeout = timeout;
            req.setRequestHeader("Content-Type", accept);

            req.onerror = function () {
                callback && callback(null);
            };

            req.onreadystatechange = function () {
                if (req.readyState === _this15.states.complete && callback) {
                    var response = _this15.parseJSON(req.responseText);

                    callback(response);
                }
            };

            if (ontimeout) {
                req.ontimeout = ontimeout;
            }

            req.send(body);
        }
    }, {
        key: "parseJSON",
        value: function parseJSON(resp) {
            if (!resp || resp === "") {
                return null;
            }

            try {
                return JSON.parse(resp);
            } catch (e) {
                console && console.log("failed to parse JSON response", resp);
                return null;
            }
        }
    }, {
        key: "serialize",
        value: function serialize(obj, parentKey) {
            var queryStr = [];

            for (var key in obj) {
                if (!obj.hasOwnProperty(key)) {
                    continue;
                }

                var paramKey = parentKey ? "".concat(parentKey, "[").concat(key, "]") : key;
                var paramVal = obj[key];

                if (_typeof(paramVal) === "object") {
                    queryStr.push(this.serialize(paramVal, paramKey));
                } else {
                    queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
                }
            }

            return queryStr.join("&");
        }
    }, {
        key: "appendParams",
        value: function appendParams(url, params) {
            if (Object.keys(params).length === 0) {
                return url;
            }

            var prefix = url.match(/\?/) ? "&" : "?";
            return "".concat(url).concat(prefix).concat(this.serialize(params));
        }
    }]);

    return Ajax;
}();

exports.Ajax = Ajax;
Ajax.states = {
    complete: 4
};
/**
 * Initializes the Presence
 * @param {Channel} channel - The Channel
 * @param {Object} opts - The options,
 *        for example `{events: {state: "state", diff: "diff"}}`
 */

var Presence = /*#__PURE__*/function () {
    function Presence(channel) {
        var _this16 = this;

        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Presence);

        var events = opts.events || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.state = {};
        this.pendingDiffs = [];
        this.channel = channel;
        this.joinRef = null;
        this.caller = {
            onJoin: function onJoin() { },
            onLeave: function onLeave() { },
            onSync: function onSync() { }
        };
        this.channel.on(events.state, function (newState) {
            var _this16$caller = _this16.caller,
                onJoin = _this16$caller.onJoin,
                onLeave = _this16$caller.onLeave,
                onSync = _this16$caller.onSync;
            _this16.joinRef = _this16.channel.joinRef();
            _this16.state = Presence.syncState(_this16.state, newState, onJoin, onLeave);

            _this16.pendingDiffs.forEach(function (diff) {
                _this16.state = Presence.syncDiff(_this16.state, diff, onJoin, onLeave);
            });

            _this16.pendingDiffs = [];
            onSync();
        });
        this.channel.on(events.diff, function (diff) {
            var _this16$caller2 = _this16.caller,
                onJoin = _this16$caller2.onJoin,
                onLeave = _this16$caller2.onLeave,
                onSync = _this16$caller2.onSync;

            if (_this16.inPendingSyncState()) {
                _this16.pendingDiffs.push(diff);
            } else {
                _this16.state = Presence.syncDiff(_this16.state, diff, onJoin, onLeave);
                onSync();
            }
        });
    }

    _createClass(Presence, [{
        key: "onJoin",
        value: function onJoin(callback) {
            this.caller.onJoin = callback;
        }
    }, {
        key: "onLeave",
        value: function onLeave(callback) {
            this.caller.onLeave = callback;
        }
    }, {
        key: "onSync",
        value: function onSync(callback) {
            this.caller.onSync = callback;
        }
    }, {
        key: "list",
        value: function list(by) {
            return Presence.list(this.state, by);
        }
    }, {
        key: "inPendingSyncState",
        value: function inPendingSyncState() {
            return !this.joinRef || this.joinRef !== this.channel.joinRef();
        } // lower-level public static API

        /**
         * Used to sync the list of presences on the server
         * with the client's state. An optional `onJoin` and `onLeave` callback can
         * be provided to react to changes in the client's local presences across
         * disconnects and reconnects with the server.
         *
         * @returns {Presence}
         */

    }], [{
        key: "syncState",
        value: function syncState(currentState, newState, onJoin, onLeave) {
            var _this17 = this;

            var state = this.clone(currentState);
            var joins = {};
            var leaves = {};
            this.map(state, function (key, presence) {
                if (!newState[key]) {
                    leaves[key] = presence;
                }
            });
            this.map(newState, function (key, newPresence) {
                var currentPresence = state[key];

                if (currentPresence) {
                    var newRefs = newPresence.metas.map(function (m) {
                        return m.phx_ref;
                    });
                    var curRefs = currentPresence.metas.map(function (m) {
                        return m.phx_ref;
                    });
                    var joinedMetas = newPresence.metas.filter(function (m) {
                        return curRefs.indexOf(m.phx_ref) < 0;
                    });
                    var leftMetas = currentPresence.metas.filter(function (m) {
                        return newRefs.indexOf(m.phx_ref) < 0;
                    });

                    if (joinedMetas.length > 0) {
                        joins[key] = newPresence;
                        joins[key].metas = joinedMetas;
                    }

                    if (leftMetas.length > 0) {
                        leaves[key] = _this17.clone(currentPresence);
                        leaves[key].metas = leftMetas;
                    }
                } else {
                    joins[key] = newPresence;
                }
            });
            return this.syncDiff(state, {
                joins: joins,
                leaves: leaves
            }, onJoin, onLeave);
        }
        /**
         *
         * Used to sync a diff of presence join and leave
         * events from the server, as they happen. Like `syncState`, `syncDiff`
         * accepts optional `onJoin` and `onLeave` callbacks to react to a user
         * joining or leaving from a device.
         *
         * @returns {Presence}
         */

    }, {
        key: "syncDiff",
        value: function syncDiff(currentState, _ref10, onJoin, onLeave) {
            var joins = _ref10.joins,
                leaves = _ref10.leaves;
            var state = this.clone(currentState);

            if (!onJoin) {
                onJoin = function onJoin() { };
            }

            if (!onLeave) {
                onLeave = function onLeave() { };
            }

            this.map(joins, function (key, newPresence) {
                var currentPresence = state[key];
                state[key] = newPresence;

                if (currentPresence) {
                    var _state$key$metas;

                    var joinedRefs = state[key].metas.map(function (m) {
                        return m.phx_ref;
                    });
                    var curMetas = currentPresence.metas.filter(function (m) {
                        return joinedRefs.indexOf(m.phx_ref) < 0;
                    });

                    (_state$key$metas = state[key].metas).unshift.apply(_state$key$metas, _toConsumableArray(curMetas));
                }

                onJoin(key, currentPresence, newPresence);
            });
            this.map(leaves, function (key, leftPresence) {
                var currentPresence = state[key];

                if (!currentPresence) {
                    return;
                }

                var refsToRemove = leftPresence.metas.map(function (m) {
                    return m.phx_ref;
                });
                currentPresence.metas = currentPresence.metas.filter(function (p) {
                    return refsToRemove.indexOf(p.phx_ref) < 0;
                });
                onLeave(key, currentPresence, leftPresence);

                if (currentPresence.metas.length === 0) {
                    delete state[key];
                }
            });
            return state;
        }
        /**
         * Returns the array of presences, with selected metadata.
         *
         * @param {Object} presences
         * @param {Function} chooser
         *
         * @returns {Presence}
         */

    }, {
        key: "list",
        value: function list(presences, chooser) {
            if (!chooser) {
                chooser = function chooser(key, pres) {
                    return pres;
                };
            }

            return this.map(presences, function (key, presence) {
                return chooser(key, presence);
            });
        } // private

    }, {
        key: "map",
        value: function map(obj, func) {
            return Object.getOwnPropertyNames(obj).map(function (key) {
                return func(key, obj[key]);
            });
        }
    }, {
        key: "clone",
        value: function clone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }
    }]);

    return Presence;
}();
/**
 *
 * Creates a timer that accepts a `timerCalc` function to perform
 * calculated timeout retries, such as exponential backoff.
 *
 * @example
 * let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *   return [1000, 5000, 10000][tries - 1] || 10000
 * })
 * reconnectTimer.scheduleTimeout() // fires after 1000
 * reconnectTimer.scheduleTimeout() // fires after 5000
 * reconnectTimer.reset()
 * reconnectTimer.scheduleTimeout() // fires after 1000
 *
 * @param {Function} callback
 * @param {Function} timerCalc
 */


exports.Presence = Presence;

var Timer = /*#__PURE__*/function () {
    function Timer(callback, timerCalc) {
        _classCallCheck(this, Timer);

        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = null;
        this.tries = 0;
    }

    _createClass(Timer, [{
        key: "reset",
        value: function reset() {
            this.tries = 0;
            clearTimeout(this.timer);
        }
        /**
         * Cancels any previous scheduleTimeout and schedules callback
         */

    }, {
        key: "scheduleTimeout",
        value: function scheduleTimeout() {
            var _this18 = this;

            clearTimeout(this.timer);
            this.timer = setTimeout(function () {
                _this18.tries = _this18.tries + 1;

                _this18.callback();
            }, this.timerCalc(this.tries + 1));
        }
    }]);

    return Timer;
}();